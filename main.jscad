/*
 * Modifications copyright Kyle Stemen.
 *
 * This is a direct port of https://github.com/adereth/dactyl-keyboard. The
 * original clojure code is copyright Matthew Adereth.
 *
 * This file is distributed under the GNU AFFERO GENERAL PUBLIC LICENSE Version
 * 3 license. The models generated by this file can be distributed under the
 * Creative Commons Attribution-ShareAlike License Version 4.0.
 */

include("gl_vec3.jscad");
include("get_plane_normal.jscad");
include("point_line_distance.jscad");
include("quickhull3d.jscad");

var draft_mode = true;

// Return an array of values, starting at `start` and going up to but not including `end`.
function range(start, end, step) {
  if (!step) {
    step = 1;
  }
  let result = [];
  for (let x = start; x < end - step/1000; x += step) {
    result.push(x);
  }
  return result;
}

function Is2DPathCounterClockwise(path) {
  let sum = 0;
  for (let i = 0; i < path.length - 1; ++i) {
    const x1 = path[i][0];
    const y1 = path[i][1];
    const x2 = path[i + 1][0];
    const y2 = path[i + 1][1];
    sum += (x2 - x1) * (y2 + y1);
  }
  if (path.length > 0) {
    const x1 = path[path.length - 1][0];
    const y1 = path[path.length - 1][1];
    const x2 = path[0][0];
    const y2 = path[0][1];
    sum += (x2 - x1) * (y2 + y1);
  }
  return sum < -1e-12;
}

class Redirect {
  constructor(dest) {
    this.dest = dest;
  }
}

class ForwardVertexList {
  constructor(initial) {
    this.array = initial.slice();
    this.array.push(new Redirect(-1));
    this.set = {};
    for (const v of initial) {
      this.set[v] = true;
    }
  }

  resolveIndex(index) {
    while (this.array[index] instanceof Redirect) {
      index = this.array[index].dest;
    }
    return index;
  }

  isEnd(index) {
    return this.resolveIndex(index) === -1;
  }

  getAt(index) {
    return this.array[this.resolveIndex(index)];
  }
  
  getSize() {
    return this.set.length;
  }

  insertArrayAt(index, new_array) {
    index = this.resolveIndex(index);
    const new_location = this.array.length;
    // Add the new array to the end.
    this.array.push(...new_array);
    for (const v of new_array) {
      this.set[v] = true;
    }
    // Copy the old value to the end of the array to make room for the
    // redirect.
    this.array.push(this.array[index]);
    // Add the redirect to go from the old location to where the new array was
    // inserted.
    this.array[index] = new Redirect(new_location);
    // Add one more redirect to go to the next element in the old location.
    this.array.push(new Redirect(index + 1));
    return new_location;
  }

  contains(value) {
    return this.set[value];
  }

  flatten() {
    const result = [];
    let index = 0;
    while (index != -1) {
      const value = this.array[index];
      if (value instanceof Redirect) {
        index = value.dest;
      } else {
        result.push(value);
        index++;
      }
    }
    return result;
  }
}

// Create a polygon from a path that may be self intersecting
function safe_polygon(path) {
  try {
    return polygon(path);
  } catch(e) {
    if (e.message != "Polygon is self intersecting!") {
      throw e;
    }
    const split_index = path.length / 2;
    const poly1 = path.slice(0, split_index + 1);
    const poly2 = path.slice(split_index);
    poly2.push(path[0]);
    return union(safe_polygon(poly1), safe_polygon(poly2));
  }
}

function projection(shape) {
  const start = performance.now();
  const vertex_to_objects = {};
  const converted_paths = [];
  let merged = 0;
  for (const polygon3d of shape.polygons) {
    const path3d = polygon3d.vertices;
    const path2d = [];
    for (const v of path3d) {
      const v2 = [v.pos.x, v.pos.y];
      if (v2[0] > -1e-10 && v2[0] < 1e-10) {
        v2[0] = 0;
      }
      if (v2[1] > -1e-10 && v2[1] < 1e-10) {
        v2[1] = 0;
      }
      path2d.push(v2);
    }
    if (!Is2DPathCounterClockwise(path2d)) {
      continue;
    }
    // Try to merge with an existing path
    let matched = false;
    for (let i = path2d.length - 1; i >= 0 && !matched; i--) {
      const candidates = vertex_to_objects[ path2d[i] ];
      if (!candidates)
        continue;
      for (const candidate of candidates) {
        const candidate_path = candidate[0];
        let candidate_next_index = candidate[1] + 1;
        if (candidate_path.isEnd(candidate_next_index)) {
          candidate_next_index = 0;
        }
        const candidate_next_value = candidate_path.getAt(candidate_next_index);
        const my_prev_index = (i === 0) ? (path3d.length - 1) : (i - 1);
        if (candidate_next_value[0] == path2d[my_prev_index][0] &&
            candidate_next_value[1] == path2d[my_prev_index][1] ) {
          const concatted = i > my_prev_index ?
            path2d.slice(i + 1).concat(path2d.slice(0, my_prev_index)) :
            path2d.slice(i + 1, my_prev_index);
          let matched_too_many = false;
          for (const v of concatted) {
            if (candidate_path.contains(v)) {
              matched_too_many = true;
              break;
            }
          }
          if (matched_too_many) {
            continue;
          }
          const inserted_index = candidate_path.insertArrayAt(candidate_next_index, concatted);
          for (let j = 0; j < path2d.length - 2; j++) {
            const set_vertex = candidate_path.getAt(inserted_index + j);
            const candidate_list = vertex_to_objects[set_vertex] || [];
            vertex_to_objects[set_vertex] = candidate_list;
            candidate_list.push([candidate_path, inserted_index + j]);
          }
          matched = true;
          merged++;
          break;
        }
        if (matched) {
          break;
        }
      }
    }
    if (!matched) {
      const converted = new ForwardVertexList(path2d);
      converted_paths.push(converted);
      for (let i = 0; i < path2d.length; i++) {
        const set_vertex = converted.getAt(i);
        const candidate_list = vertex_to_objects[set_vertex] || [];
        vertex_to_objects[set_vertex] = candidate_list;
        candidate_list.push([converted, i]);
      }
    }
  }
  for (let i = 0; i < converted_paths.length; i++) {
    converted_paths[i] = safe_polygon(converted_paths[i].flatten());
  }
  return tree_union(converted_paths);
}

/* util.clj */
function triangle_hulls(...shapes) {
  return union(Array.from(function*() {
    for (let i = 0; i < shapes.length - 2; i++) {
      yield quickhull3d(shapes[i], shapes[i+1], shapes[i+2]);
    }
  }()));
}

function bottom(height, p) {
  return linear_extrude({height: height, twist: 0, center: false}, projection(p));
}

function bottom_hull(p) {
  return quickhull3d(p, bottom(1, p));
}

/****************
** Switch Hole **
****************/

const keyswitch_height = 14.4; // Was 14.1, then 14.25
const keyswitch_width = 14.4;

const sa_profile_key_height = 12.7;

const plate_thickness = 4;
const mount_width = keyswitch_width + 3;
const mount_height = keyswitch_height + 3;

function old_single_plate() {
  const top_wall = translate(
    [0, 1.5/2 + keyswitch_height/2, plate_thickness/2],
    cube({size: [keyswitch_width + 3, 1.5, plate_thickness], center: true}));

  const left_wall = translate(
    [1.5/2 + keyswitch_width/2, 0, plate_thickness/2],
    cube({size: [1.5, keyswitch_height + 3, plate_thickness], center: true}));

  const side_nub = quickhull3d(
    translate(
      [1.5/2 + keyswitch_width/2, 0, plate_thickness/2],
      cube({size: [1.5, 2.75, plate_thickness], center: true})),
    translate([keyswitch_width/2, 0, 1],
      rotate(Math.PI/2*180/Math.PI, [1, 0, 0],
        cylinder({r: 1, h: 2.75, center: true, fn: draft_mode ? 10 : 30}))));

  const plate_half = union(top_wall, left_wall, side_nub);
  return union(
    plate_half,
    mirror([0, 1, 0], mirror([1, 0, 0], plate_half)));
}

const alps_width = 15.6;
const alps_notch_width = 15.5;
const alps_notch_height = 1;
const alps_height = 13;

function single_plate() {
    const top_wall = translate(
        [0, 2.2/2 + alps_height/2, plate_thickness/2],
        cube({size: [keyswitch_width + 3, 2.2, plate_thickness], center: true}));
    const left_wall = union(
        translate([1.5/2 + 15.6/2, 0, plate_thickness/2],
            cube({size: [1.5, keyswitch_height + 3, plate_thickness], center: true})),
        translate([1.5/2 + alps_notch_width/2, 0, plate_thickness - alps_notch_height/2],
            cube({size: [1.5, keyswitch_height + 3, 1.0], center: true})));

    const plate_half = union(top_wall, left_wall);
    return union(
        plate_half,
        mirror([0, 1, 0], mirror([1, 0, 0], plate_half)));
}

/***************
** SA Keycaps **
***************/

const sa_length = 18.25;
const sa_double_length = 37.5;

const columns = range(0,6);
const rows = range(0,5);

const alpha = Math.PI / 12;
const beta = Math.PI / 36;
const cap_top_height = plate_thickness + sa_profile_key_height;
const row_radius = (mount_height + 1/2) / 2 / Math.sin(alpha/2) +
    cap_top_height;
const column_radius = (mount_width + 2.0) / 2 / Math.sin(beta/2) +
    cap_top_height;

function key_place(column, row, shape) {
    const row_placed_shape =
        translate([0, 0, row_radius],
            rotate(alpha * (2 - row) * 180 / Math.PI, [1, 0, 0],
                translate([0, 0, -row_radius], shape)));
    let column_offset;
    if (column == 2) {
        column_offset = [0, 2.82, -3.0]; // was moved -4.5
    } else if (column >= 4) {
        column_offset = [0, -5.8, 5.64];
    } else {
        column_offset = [0, 0, 0];
    }
    const column_angle = beta * (2 - column) * 180 / Math.PI;
    const placed_shape =
        translate(column_offset,
            translate([0, 0, column_radius],
                rotate(column_angle, [0, 1, 0],
                    translate([0, 0, -column_radius],
                        row_placed_shape))));

    return(
        translate([0, 0, 13],
            rotate(Math.PI / 12 * 180 / Math.PI, [0, 1, 0],
                placed_shape)));
}

function case_place(column, row, shape) {
  const row_placed_shape =
    translate([0, 0, row_radius],
      rotate(alpha * (2 - row) * 180 / Math.PI, [1, 0, 0],
        translate([0, 0, -row_radius], shape)));
  const column_offset = [0, -4.35, 5.64];
  const column_angle = beta * (2 - column);
  const placed_shape =
    translate(column_offset,
      translate([0, 0, column_radius],
        rotate(column_angle * 180 / Math.PI, [0, 1, 0],
          translate([0, 0, -column_radius],
            row_placed_shape))));
  return translate([0, 0, 13],
    rotate(Math.PI/12*180/Math.PI, [0, 1, 0], placed_shape));
}

function key_holes(params) {
  console.log("key_holes");
  return union(Array.from(
    function*() {
      const plate = params.key_switch == "cherry" ?  old_single_plate() : single_plate();
      for (const column of columns) {
        for (const row of rows) {
          if (column !== 0 || row != 4) {
           yield key_place(column, row, plate);
          }
        }
      }
  }()));
}

/*******************
** Web Connectors **
*******************/

const web_thickness = 3.5;
const post_size = 0.1;
function web_post() {
    return translate([0, 0, web_thickness/-2 + plate_thickness],
        cube({size: [post_size, post_size, web_thickness], center: true}));
}

const post_adj = post_size/2;
function web_post_tr() {
    return translate(
        [mount_width/2 - post_adj, mount_height/2 - post_adj, 0], web_post());
}
function web_post_tl() {
    return translate(
        [mount_width/-2 + post_adj, mount_height/2 - post_adj, 0], web_post());
}
function web_post_bl() {
    return translate(
        [mount_width/-2 + post_adj, mount_height/-2 + post_adj, 0], web_post());
}
function web_post_br() {
    return translate(
        [mount_width/2 - post_adj, mount_height/-2 + post_adj, 0], web_post());
}

function connectors() {
  console.log("connectors");
  const local_web_post_tl = web_post_tl();
  const local_web_post_tr = web_post_tr();
  const local_web_post_bl = web_post_bl();
  const local_web_post_br = web_post_br();

  return union(Array.from(function*() {
    // Row connections
    for (const column of columns.slice(0, -1)) {
      for (const row of rows) {
        if (column === 0 && row == 4)
          continue;
        yield triangle_hulls(
          key_place(column + 1, row, local_web_post_tl),
          key_place(column, row, local_web_post_tr),
          key_place(column + 1, row, local_web_post_bl),
          key_place(column, row, local_web_post_br));
      }
    }

    // Column connections
    for (const column of columns) {
      for (const row of rows.slice(0, -1)) {
        if (column === 0 && row == 3)
          continue;
        yield triangle_hulls(
          key_place(column, row, local_web_post_bl),
          key_place(column, row, local_web_post_br),
          key_place(column, row + 1, local_web_post_tl),
          key_place(column, row + 1, local_web_post_tr));
      }
    }

    // Diagonal connections
    for (const column of columns.slice(0, -1)) {
      for (const row of rows.slice(0, -1)) {
        if (column === 0 && row == 3)
          continue;
        yield triangle_hulls(
          key_place(column, row, local_web_post_br),
          key_place(column, row + 1, local_web_post_tr),
          key_place(column + 1, row, local_web_post_bl),
          key_place(column + 1, row + 1, local_web_post_tl));
      }
    }
  }()));
}

/***********
** Thumbs **
***********/

function thumb_place(column, row, shape) {
  return translate([-52, -45, 40],
    rotate(Math.PI/12, [1, 1, 0],
      rotate(Math.PI * (1/4 - 3/16) * 180 / Math.PI, [0, 0, 1],
        translate([mount_width, 0, 0],
          translate([0, 0, column_radius],
            rotate(column*beta*180/Math.PI, [0, 1, 0],
              translate([0, 0, -column_radius],
               translate([0, 0, row_radius],
                 rotate(alpha*row*180/Math.PI, [1, 0, 0],
                   translate([0, 0, -row_radius], shape))))))))));
}


function thumb_2x_column(shape) {
  return thumb_place(0, -1/2, shape)
}

function thumb_2x_1_column(shape) {
  return union(
    thumb_place(1, -1/2, shape),
    thumb_place(1, 1, shape));
}

function thumb_1x_column(shape) {
  return union(
    thumb_place(2, -1, shape),
    thumb_place(2, 0, shape),
    thumb_place(2, 1, shape));
}

function thumb_layout(shape) {
  return union(
   thumb_2x_column(shape),
   thumb_2x_1_column(shape),
   thumb_1x_column(shape));
}

function double_plates() {
  const plate_height = (sa_double_length - mount_height)/2;
  let top_plate =
    translate([0, (plate_height + mount_height)/2,
               plate_thickness - web_thickness/2],
      cube({size: [mount_width, plate_height, web_thickness], center: true}));

  const stabilizer_cutout = union(
    color([1, 0, 0, 1/2],
      translate([0.5, 12, plate_thickness - web_thickness/2],
        cube({size: [14.2, 3.5, web_thickness], center: true}))),
    color([1, 0, 0, 1/2],
      translate([0.5, 12, plate_thickness - web_thickness/2 - 1.4],
        cube({size: [16, 3.5, web_thickness], center: true}))));

  top_plate = difference(top_plate, stabilizer_cutout)
  return union(top_plate, mirror([0, 1, 0], top_plate));
}

function thumb_connectors() {
  return union(Array.from(function*() {
    for (const column of [2]) {
      for (const row of [1]) {
        yield triangle_hulls(
          thumb_place(column, row, web_post_br()),
          thumb_place(column, row, web_post_tr()),
          thumb_place(column - 1, row, web_post_bl()),
          thumb_place(column - 1, row, web_post_tl()));
      }
    }
    for (const column of [2]) {
      for (const row of [0, 1]) {
        yield triangle_hulls(
          thumb_place(column, row, web_post_bl()),
          thumb_place(column, row, web_post_br()),
          thumb_place(column, row - 1, web_post_tl()),
          thumb_place(column, row - 1, web_post_tr()));
      }
    }
    const plate_height = (sa_double_length - mount_height)/2;
    const thumb_tl = translate([0, plate_height, 0], web_post_tl());
    const thumb_bl = translate([0, -plate_height, 0], web_post_bl());
    const thumb_tr = translate([0, plate_height, 0], web_post_tr());
    const thumb_br = translate([0, -plate_height, 0], web_post_br());
    // Connecting the two doubles
    yield triangle_hulls(
      thumb_place(0, -1/2, thumb_tl),
      thumb_place(0, -1/2, thumb_bl),
      thumb_place(1, -1/2, thumb_tr),
      thumb_place(1, -1/2, thumb_br));

    // Connecting the double to the one above it
    yield triangle_hulls(
      thumb_place(1, -1/2, thumb_tr),
      thumb_place(1, -1/2, thumb_tl),
      thumb_place(1, 1, web_post_br()),
      thumb_place(1, 1, web_post_bl()));

    // Connecting the 4 with the double in the bottom left
    yield triangle_hulls(
      thumb_place(1, 1, web_post_bl()),
      thumb_place(1, -1/2, thumb_tl),
      thumb_place(2, 1, web_post_br()),
      thumb_place(2, 0, web_post_tr()));

    // Connecting the two singles with the middle double
    yield quickhull3d(
      thumb_place(1, -1/2, thumb_tl),
      thumb_place(1, -1/2, thumb_bl),
      thumb_place(2, 0, web_post_br()),
      thumb_place(2, -1, web_post_tr()));
    yield quickhull3d(
      thumb_place(1, -1/2, thumb_tl),
      thumb_place(2, 0, web_post_tr()),
      thumb_place(2, 0, web_post_br()));
    yield quickhull3d(
      thumb_place(1, -1/2, thumb_bl),
      thumb_place(2, -1, web_post_tr()),
      thumb_place(2, -1, web_post_br()));

    // Connecting the thumb to everything
    yield triangle_hulls(
      thumb_place(0, -1/2, thumb_br),
      key_place(1, 4, web_post_bl()),
      thumb_place(0, -1/2, thumb_tr),
      key_place(1, 4, web_post_tl()),
      key_place(1, 3, web_post_bl()),
      thumb_place(0, -1/2, thumb_tr),
      key_place(0, 3, web_post_br()),
      key_place(0, 3, web_post_bl()),
      thumb_place(0, -1/2, thumb_tr),
      thumb_place(0, -1/2, thumb_tl),
      key_place(0, 3, web_post_bl()),
      thumb_place(1, -1/2, thumb_tr),
      thumb_place(1, 1, web_post_br()),
      key_place(0, 3, web_post_bl()),
      key_place(0, 3, web_post_tl()),
      thumb_place(1, 1, web_post_br()),
      thumb_place(1, 1, web_post_tr()));

    yield quickhull3d(
      thumb_place(0, -1/2, web_post_tr()),
      thumb_place(0, -1/2, thumb_tr),
      key_place(1, 4, web_post_bl()),
      key_place(1, 4, web_post_tl()));
  }()));
}

function thumb() {
  console.log("thumb");
  const plate = params.key_switch == "cherry" ?  old_single_plate() : single_plate();
  return union(
    thumb_connectors(),
    thumb_layout(rotate(Math.PI/2*180/Math.PI, [0, 0, 1], plate)),
    thumb_place(0, -1/2, double_plates()),
    thumb_place(1, -1/2, double_plates()));
}

/*********
** Case **
*********/

// In column units
const right_wall_column = columns.slice(-1)[0] + 0.55;
const left_wall_column = columns[0] - 1/2;
const thumb_back_y = 0.93;
const thumb_right_wall = -1/2 - 0.05;
const thumb_front_row = -1 + 0.07;
const thumb_left_wall_column = 5/2 + 0.05;
const back_y = 0.02;

function range_inclusive(start, end, step) {
  return range(start, end, step).concat([end]);
}

const wall_step = 0.2;
const wall_sphere_n = 20; // Sphere resolution, lower for faster renders

function wall_sphere_at(coords) {
  const shape = draft_mode ?
    cube({size: [1, 1, 1], center: true}) :
    sphere({r: 1, center: true, fn: wall_sphere_n});
  return translate(coords, shape);
}

function scale_to_range(start, end, x) {
  return start + (end - start) * x;
}

function wall_sphere_bottom(front_to_back_scale) {
  return wall_sphere_at([0,
                   scale_to_range(
                    (mount_height/-2) + -3.5,
                    (mount_height/2) + 5.0,
                    front_to_back_scale),
                   -6]);
}

function wall_sphere_top(front_to_back_scale) {
  return wall_sphere_at([0,
                   scale_to_range(
                    (mount_height/-2) + -3.5,
                    (mount_height/2) + 3.5,
                    front_to_back_scale),
                   10]);
}

function wall_sphere_top_back() {
  return wall_sphere_top(1);
}

function wall_sphere_bottom_back() {
  return wall_sphere_bottom(1);
}

function wall_sphere_bottom_front() {
  return wall_sphere_bottom(0);
}

function wall_sphere_top_front() {
  return wall_sphere_top(0);
}

// The regular union already processes the shapes in a tree pattern, but it
// does not canonicalize and retesselate on the intermediate steps.
//
// In cases where many faces can be removed as part of the union, `tree_union`
// performs faster.
function tree_union(shapes, merge_size) {
  if (!merge_size) {
    merge_size = 2;
  }
  while (shapes.length > merge_size) {
    const new_shapes = [];
    let i;
    for (i = 0; i <= shapes.length - merge_size; i += merge_size) {
      new_shapes.push(union(shapes.slice(i, i + merge_size)));
    }
    new_shapes.push(...shapes.slice(i));
    shapes = new_shapes;
  }
  if (shapes.length > 1) {
    return union(shapes);
  } else {
    return shapes[0];
  }
}

function top_case_cover(place_fn, sphere,
                 x_start, x_end,
                 y_start, y_end,
                 step) {
  return tree_union(Array.from(function*() {
    for (const x of range_inclusive(x_start, x_end - step, step)) {
      for (const y of range_inclusive(y_start, y_end - step, step)) {
        yield quickhull3d(
          place_fn(x, y, sphere),
          place_fn(x + step, y, sphere),
          place_fn(x, y + step, sphere),
          place_fn(x + step, y + step, sphere));
      }
    }
  }()));
}

function front_wall() {
  console.log("front_wall");
  const step = wall_step; // 0.1
  const local_wall_step = draft_mode ? 0.2 : 0.05; // 0.05
  const place = case_place;
  const top_cover = function(x_start, x_end, y_start, y_end) {
    return top_case_cover(place, wall_sphere_top_front(), x_start, x_end, y_start, y_end, local_wall_step);
  };
  const top_cover_edge = function(x_start, x_end, y) {
    const sphere = wall_sphere_top_front();
    return tree_union(Array.from(function*() {
      for (const x of range_inclusive(x_start, x_end - step, step)) {
          yield quickhull3d(
            place(x, y, sphere),
            place(x + step, y, sphere));
      }
    }()));
  };
  const local_wall_sphere_top_front = wall_sphere_top_front();
  const local_wall_sphere_bottom_front = wall_sphere_bottom_front();

  return tree_union(Array.from(function*() {
    for (const x of range_inclusive(0.7, right_wall_column - step, step)) {
      yield quickhull3d(
        place(x, 4, local_wall_sphere_top_front),
        place(x + step, 4, local_wall_sphere_top_front),
        place(x, 4, local_wall_sphere_bottom_front),
        place(x + step, 4, local_wall_sphere_bottom_front));
    }
    for (const x of range_inclusive(0.5, 0.7, draft_mode ? 0.1 : 0.01)) {
      yield quickhull3d(
        place(x, 4, local_wall_sphere_top_front),
        place(x + step, 4, local_wall_sphere_top_front),
        place(0.7, 4, local_wall_sphere_bottom_front));
    }
    yield top_cover(0.5, 1.7, 3.6, 4);
    yield top_cover(1.59, 2.41, 3.35, 4); // was 3.32
    yield quickhull3d(
        top_cover_edge(1.59, 2.41, 3.35),
        translate([0, 0, -1.5], key_place(2, 4 + 1/4, web_post_bl())),
        translate([0, 0, -1.5], key_place(2, 4 + 1/4, web_post_br())));
    yield top_cover(2.39, 3.41, 3.6, 4);

    for (const x of range(2, 5)) {
      yield quickhull3d(
        place(x - 1/2, 4, translate([0, 1, 1], local_wall_sphere_bottom_front)),
        place(x + 1/2, 4, translate([0, 1, 1], local_wall_sphere_bottom_front)),
        key_place(x, 4, web_post_bl()),
        key_place(x, 4, web_post_br()));
      yield quickhull3d(
        place(x - 1/2, 4, translate([0, 1, 1], local_wall_sphere_bottom_front)),
        key_place(x, 4, web_post_bl()),
        key_place(x - 1, 4, web_post_br()));
    }
    yield quickhull3d(
      place(right_wall_column, 4, translate([0, 1, 1], local_wall_sphere_bottom_front)),
      place(right_wall_column - 1, 4, translate([0, 1, 1], local_wall_sphere_bottom_front)),
      key_place(5, 4, web_post_bl()),
      key_place(5, 4, web_post_br()));
    yield quickhull3d(
      place(4 + 1/2, 4, translate([0, 1, 1,], local_wall_sphere_bottom_front)),
      place(right_wall_column - 1, 4, translate([0, 1, 1], local_wall_sphere_bottom_front)),
      key_place(4, 4, web_post_br()),
      key_place(5, 4, web_post_bl()));
    yield quickhull3d(
      place(0.7, 4, translate([0, 1, 1], local_wall_sphere_bottom_front)),
      place(1.7, 4, translate([0, 1, 1], local_wall_sphere_bottom_front)),
      key_place(1, 4, web_post_bl()),
      key_place(1, 4, web_post_br()));
  }()));
}

function back_wall() {
  console.log("back_wall");
  const step = wall_step;
  const wall_sphere_top_backtep = 0.05;
  const wall_sphere_top_backtep_x = draft_mode ? 0.2 : wall_sphere_top_backtep;
  const place = case_place;
  const front_top_cover = function(x_start, x_end, y_start, y_end) {
    return tree_union(Array.from(function*() {
      for (const x of range_inclusive(x_start, x_end - wall_sphere_top_backtep_x, wall_sphere_top_backtep_x)) {
        for (const y of range_inclusive(y_start, y_end - wall_sphere_top_backtep, wall_sphere_top_backtep)) {
          yield quickhull3d(
            place(x, y, wall_sphere_top_back()),
            place(x + wall_sphere_top_backtep_x, y, wall_sphere_top_back()),
            place(x, y + wall_sphere_top_backtep, wall_sphere_top_back()),
            place(x + wall_sphere_top_backtep_x, y + wall_sphere_top_backtep, wall_sphere_top_back()));
        }
      }
    }()));
  };
  return tree_union(Array.from(function*() {
    for (const x of range_inclusive(left_wall_column, right_wall_column - step, step)) {
      yield quickhull3d(
        place(x, back_y, wall_sphere_top_back()),
        place(x + step, back_y, wall_sphere_top_back()),
        place(x, back_y, wall_sphere_bottom_back()),
        place(x + step, back_y, wall_sphere_bottom_back()));
    }
    yield front_top_cover(1.56, 2.44, back_y, 0.1);
    yield front_top_cover(3.56, 4.44, back_y, 0.13);
    yield front_top_cover(4.3, right_wall_column, back_y, 0.13);

    yield quickhull3d(
      place(left_wall_column, 0, translate([1, -1, 1], wall_sphere_bottom_back())),
      place(left_wall_column + 1, 0,  translate([0, -1, 1], wall_sphere_bottom_back())),
      key_place(0, 0, web_post_tl()),
      key_place(0, 0, web_post_tr()));

    yield quickhull3d(
      place(5, 0, translate([0, -1, 1], wall_sphere_bottom_back())),
      place(right_wall_column, 0, translate([0, -1, 1], wall_sphere_bottom_back())),
      key_place(5, 0, web_post_tl()),
      key_place(5, 0, web_post_tr()));

    for (const x of range(1, 5)) {
      yield quickhull3d(
        place(x - 1/2, 0, translate([0, -1, 1], wall_sphere_bottom_back())),
        place(x + 1/2, 0, translate([0, -1, 1], wall_sphere_bottom_back())),
        key_place(x, 0, web_post_tl()),
        key_place(x, 0, web_post_tr()));
      yield quickhull3d(
        place(x - 1/2, 0, translate([0, -1, 1], wall_sphere_bottom_back())),
        key_place(x, 0, web_post_tl()),
        key_place(x - 1, 0, web_post_tr()));
    }
    yield quickhull3d(
      place(5 - 1/2, 0, translate([0, -1, 1], wall_sphere_bottom_back())),
      place(5, 0, translate([0, -1, 1], wall_sphere_bottom_back())),
      key_place(4, 0, web_post_tr()),
      key_place(5, 0, web_post_tl()));
  }()));
}

function right_wall() {
  console.log("right_wall");
  const place = case_place;
  return tree_union(Array.from(function*() {
    let side_blocks = [];
    for (const scale of range_inclusive(0, 1, draft_mode ? 0.1 : 0.01)) {
      const x = scale_to_range(4, 0.02, scale);
      side_blocks.push(quickhull3d(
        place(right_wall_column, x, wall_sphere_top(scale)),
        place(right_wall_column, x, wall_sphere_bottom(scale))));
    }
    for (let i = 0; i < side_blocks.length - 1; i++) {
      yield quickhull3d(side_blocks[i], side_blocks[i+1]);
    }
    for (const x of range(0, 5)) {
      yield quickhull3d(
        place(right_wall_column, x, translate([-1, 0, 1], wall_sphere_bottom(1/2))),
        key_place(5, x, web_post_br()),
        key_place(5, x, web_post_tr()));
    }
    for (const x of range(0, 4)) {
      yield quickhull3d(
        place(right_wall_column, x, translate([-1, 0, 1], wall_sphere_bottom(1/2))),
        place(right_wall_column, x + 1, translate([-1, 0, 1], wall_sphere_bottom(1/2))),
        key_place(5, x, web_post_br()),
        key_place(5, x + 1, web_post_tr()));
      yield quickhull3d(
        place(right_wall_column, 0, translate([-1, 0, 1], wall_sphere_bottom(1/2))),
        place(right_wall_column, 0.02, translate([-1, -1, 1], wall_sphere_bottom(1))),
        key_place(5, 0, web_post_tr()));
      yield quickhull3d(
        place(right_wall_column, 4, translate([-1, 0, 1], wall_sphere_bottom(1/2))),
        place(right_wall_column, 4, translate([-1, 1, 1], wall_sphere_bottom(0))),
        key_place(5, 4, web_post_br()));
    }
  }()));
}

function left_wall() {
  console.log("left_wall");
  const place = case_place;
  return tree_union(Array.from(function*() {
    for (const x of range_inclusive(-1, 1.6666 - wall_step, wall_step)) {
      yield quickhull3d(
        place(left_wall_column, x, wall_sphere_top_front()),
        place(left_wall_column, x + wall_step, wall_sphere_top_front()),
        place(left_wall_column, x, wall_sphere_bottom_front()),
        place(left_wall_column, x + wall_step, wall_sphere_bottom_front()));
    }
    yield quickhull3d(
      place(left_wall_column, -1, wall_sphere_top_front()),
      place(left_wall_column, -1, wall_sphere_bottom_front()),
      place(left_wall_column, 0.02, wall_sphere_top_back()),
      place(left_wall_column, 0.02, wall_sphere_bottom_back()));
    yield quickhull3d(
      place(left_wall_column, 0, translate([1, -1, 1], wall_sphere_bottom_back())),
      place(left_wall_column, 1, translate([1, 0, 1], wall_sphere_bottom_back())),
      key_place(0, 0, web_post_tl()),
      key_place(0, 0, web_post_bl()));
    yield quickhull3d(
      place(left_wall_column, 1, translate([1, 0, 1], wall_sphere_bottom_back())),
      place(left_wall_column, 2, translate([1, 0, 1], wall_sphere_bottom_back())),
      key_place(0, 0, web_post_bl()),
      key_place(0, 1, web_post_bl()));
    yield quickhull3d(
      place(left_wall_column, 2, translate([1, 0, 1], wall_sphere_bottom_back())),
      place(left_wall_column, 1.6666, translate([1, 0, 1], wall_sphere_bottom_front())),
      key_place(0, 1, web_post_bl()),
      key_place(0, 2, web_post_bl()));
    yield quickhull3d(
      place(left_wall_column, 1.6666, translate([1, 0, 1], wall_sphere_bottom_front())),
      key_place(0, 2, web_post_bl()),
      key_place(0, 3, web_post_tl()));
    yield quickhull3d(
      place(left_wall_column, 1.6666, translate([1, 0, 1], wall_sphere_bottom_front())),
      thumb_place(1, 1, web_post_tr()),
      key_place(0, 3, web_post_tl()));
    yield quickhull3d(
      place(left_wall_column, 1.6666, translate([1, 0, 1], wall_sphere_bottom_front())),
      thumb_place(1, 1, web_post_tr()),
      thumb_place(1/2, thumb_back_y, translate([0, -1, 1], wall_sphere_bottom_back())));
  }()));
}

function thumb_back_wall() {
  console.log("thumb_back_wall");
  const step = wall_step;
  const top_step = 0.05;
  const front_top_cover = function(x_start, x_end, y_start, y_end) {
    return tree_union(Array.from(function*() {
      for (const x of range_inclusive(x_start, x_end - top_step, top_step)) {
        for (const y of range_inclusive(y_start, y_end - top_step, top_step)) {
          yield quickhull3d(
            thumb_place(x, y, wall_sphere_top_back()),
            thumb_place(x + top_step, y, wall_sphere_top_back()),
            thumb_place(x, y + top_step, wall_sphere_top_back()),
            thumb_place(x + top_step, y + top_step, wall_sphere_top_back()));
        }
      }
    }()));
  };
  const back_y = thumb_back_y;
  return tree_union(Array.from(function*() {
    for (x of range_inclusive(1/2, 5/2 + 0.05 - step, step)) {
      yield quickhull3d(
        thumb_place(x, back_y, wall_sphere_top_back()),
        thumb_place(x + step, back_y, wall_sphere_top_back()),
        thumb_place(x, back_y, wall_sphere_bottom_back()),
        thumb_place(x + step, back_y, wall_sphere_bottom_back()));
    }
    yield quickhull3d(
      thumb_place(1/2, back_y, wall_sphere_top_back()),
      thumb_place(1/2, back_y, wall_sphere_bottom_back()),
      case_place(left_wall_column, 1.6666, wall_sphere_top_front()));
    yield quickhull3d(
      thumb_place(1/2, back_y, wall_sphere_bottom_back()),
      case_place(left_wall_column, 1.6666, wall_sphere_top_front()),
      case_place(left_wall_column, 1.6666, wall_sphere_bottom_front()));
    yield quickhull3d(
      thumb_place(1/2, thumb_back_y, translate([0, -1, 1], wall_sphere_bottom_back())),
      thumb_place(1, 1, web_post_tr()),
      thumb_place(3/2, thumb_back_y, translate([0, -1, 1], wall_sphere_bottom_back())),
      thumb_place(1, 1, web_post_tl()));
    yield quickhull3d(
      thumb_place(5/2 + 0.05, thumb_back_y, translate([1, -1, 1], wall_sphere_bottom_back())),
      thumb_place(3/2, thumb_back_y, translate([0, -1, 1], wall_sphere_bottom_back())),
      thumb_place(1, 1, web_post_tl()),
      thumb_place(2, 1, web_post_tl()));
  }()));
}

function thumb_left_wall() {
  console.log("thumb_left_wall");
  const step = wall_step;
  const place = thumb_place;
  return tree_union(Array.from(function*() {
    for (x of range_inclusive(-1 + 0.07, 1.95 - step, step)) {
      yield quickhull3d(
        place(thumb_left_wall_column, x, wall_sphere_top_front()),
        place(thumb_left_wall_column, x + step, wall_sphere_top_front()),
        place(thumb_left_wall_column, x, wall_sphere_bottom_front()),
        place(thumb_left_wall_column, x + step, wall_sphere_bottom_front()));
    }

    yield quickhull3d(
      place(thumb_left_wall_column, 1.95, wall_sphere_top_front()),
      place(thumb_left_wall_column, 1.95, wall_sphere_bottom_front()),
      place(thumb_left_wall_column, thumb_back_y, wall_sphere_top_back()),
      place(thumb_left_wall_column, thumb_back_y, wall_sphere_bottom_back()));
    yield quickhull3d(
      thumb_place(thumb_left_wall_column, thumb_back_y, translate([1, -1, 1], wall_sphere_bottom_back())),
      thumb_place(thumb_left_wall_column, 0, translate([1, 0, 1], wall_sphere_bottom_back())),
      thumb_place(2, 1, web_post_tl()),
      thumb_place(2, 1, web_post_bl()));
    yield quickhull3d(
      thumb_place(thumb_left_wall_column, 0, translate([1, 0, 1], wall_sphere_bottom_back())),
      thumb_place(2, 0, web_post_tl()),
      thumb_place(2, 1, web_post_bl()));
    yield quickhull3d(
      thumb_place(thumb_left_wall_column, 0, translate([1, 0, 1], wall_sphere_bottom_back())),
      thumb_place(thumb_left_wall_column, -1, translate([1, 0, 1], wall_sphere_bottom_back())),
      thumb_place(2, 0, web_post_tl()),
      thumb_place(2, 0, web_post_bl()));
    yield quickhull3d(
      thumb_place(thumb_left_wall_column, -1, translate([1, 0, 1], wall_sphere_bottom_back())),
      thumb_place(2, -1, web_post_tl()),
      thumb_place(2, 0, web_post_bl()));
    yield quickhull3d(
      thumb_place(thumb_left_wall_column, -1, translate([1, 0, 1], wall_sphere_bottom_back())),
      thumb_place(thumb_left_wall_column, -1 + 0.07, translate([1, 1, 1], wall_sphere_bottom_front())),
      thumb_place(2, -1, web_post_tl()),
      thumb_place(2, -1, web_post_bl()));
  }()));
}

function thumb_front_wall() {
  console.log("thumb_front_wall");
  const step = wall_step; //0.1
  const wall_sphere_top_fronttep = 0.05; //0.05
  const place = thumb_place;
  const plate_height = (sa_double_length - mount_height) / 2;
  const thumb_tl = translate([0, plate_height, 0], web_post_tl());
  const thumb_bl = translate([0, -plate_height, 0], web_post_bl());
  const thumb_tr = translate([-0, plate_height, 0], web_post_tr());
  const thumb_br = translate([-0, -plate_height, 0], web_post_br());

  return tree_union(Array.from(function*() {
    for (x of range_inclusive(thumb_right_wall, 5/2 + 0.05 - step, step)) {
     yield quickhull3d(
       place(x, thumb_front_row, wall_sphere_top_front()),
       place(x + step, thumb_front_row, wall_sphere_top_front()),
       place(x, thumb_front_row, wall_sphere_bottom_front()),
       place(x + step, thumb_front_row, wall_sphere_bottom_front()));
    }

    yield quickhull3d(
      place(thumb_right_wall, thumb_front_row, wall_sphere_top_front()),
      place(thumb_right_wall, thumb_front_row, wall_sphere_bottom_front()),
      case_place(0.5, 4, wall_sphere_top_front()));
    yield quickhull3d(
      place(thumb_right_wall, thumb_front_row, wall_sphere_bottom_front()),
      case_place(0.5, 4, wall_sphere_top_front()),
      case_place(0.7, 4, wall_sphere_bottom_front()));

    yield quickhull3d(
      place(thumb_right_wall, thumb_front_row, wall_sphere_bottom_front()),
      key_place(1, 4, web_post_bl()),
      place(0, -1/2, thumb_br),
      place(0, -1/2, web_post_br()),
      case_place(0.7, 4, wall_sphere_bottom_front()));

    yield quickhull3d(
      place(5/2 + 0.05, thumb_front_row, translate([1, 1, 1], wall_sphere_bottom_front())),
      place(3/2 + 0.05, thumb_front_row, translate([0, 1, 1], wall_sphere_bottom_front())),
      place(2, -1, web_post_bl()),
      place(2, -1, web_post_br()));

    yield quickhull3d(
      place(thumb_right_wall, thumb_front_row, translate([0, 1, 1], wall_sphere_bottom_front())),
      place(1/2 + 0.05, thumb_front_row, translate([0, 1, 1], wall_sphere_bottom_front())),
      place(0, -1/2, thumb_bl),
      place(0, -1/2, thumb_br));
    yield quickhull3d(
      place(1/2 + 0.05, thumb_front_row, translate([0, 1, 1], wall_sphere_bottom_front())),
      place(3/2 + 0.05, thumb_front_row, translate([0, 1, 1], wall_sphere_bottom_front())),
      place(0, -1/2, thumb_bl),
      place(1, -1/2, thumb_bl),
      place(1, -1/2, thumb_br),
      place(2, -1, web_post_br()));
  }()));
}

function new_case() {
  console.log("new_case");
  return union(front_wall(), right_wall(), back_wall(), left_wall(), thumb_back_wall(), thumb_left_wall(), thumb_front_wall());
}

/***********
** Bottom **
***********/


function bottom_key_guard() {
  return translate([0, 0, -web_thickness/2 + -4.5],
    cube({size: [mount_width, mount_height, web_thickness], center: true}));
}

function bottom_front_key_guard() {
  return translate([0, mount_height/4, (-web_thickness/2) + -4.5],
    cube({size: [mount_width, mount_height/2, web_thickness], center: true}));
}

function bottom_plate() {
  return tree_union(Array.from(function*() {
    for (const column of columns) {
      for (const row of rows.slice(0, -1)) {
        if (! (column != 0 || row != 4) )
          continue;
        yield key_place(column, row, bottom_key_guard());
      }
    }

    yield thumb_layout(rotate(Math.PI/2*180/Math.PI, [0, 0, 1], bottom_key_guard()));

    for (const column of columns) {
      for (const row of rows.slice(-1)) {
        if (! (column != 0 || row != 4) )
          continue;
        yield key_place(column, row, bottom_front_key_guard());
      }
    }

    const shift = function(shape) {
      return translate([0, 0, -web_thickness + -5], shape);
    };
    const local_web_post_tl = shift(web_post_tl());
    const local_web_post_tr = shift(web_post_tr());
    const local_web_post_br = shift(web_post_br());
    const local_web_post_bl = shift(web_post_bl());

    const half_shift_correction = function(shape) {
      return translate([0, mount_height/2, 0], shape);
    };
    const half_post_br = half_shift_correction(local_web_post_br);
    const half_post_bl = half_shift_correction(local_web_post_bl);
    const row_connections = tree_union(Array.from(function*() {
      for (const column of columns.slice(0, -1)) {
        for (const row of rows.slice(0, -1)) {
          if (! (column != 0 || row != 4) )
            continue;
          yield triangle_hulls(
            key_place(column + 1, row, local_web_post_tl),
            key_place(column, row, local_web_post_tr),
            key_place(column + 1, row, local_web_post_bl),
            key_place(column, row, local_web_post_br));
        }
      }
      for (const column of columns.slice(0, -1)) {
        for (const row of rows.slice(-1)) {
          if (! (column != 0 || row != 4) )
            continue;
          yield triangle_hulls(
            key_place(column + 1, row, local_web_post_tl),
            key_place(column, row, local_web_post_tr),
            key_place(column + 1, row, half_post_bl),
            key_place(column, row, half_post_br));
        }
      }
    }()));
    const column_connections = tree_union(Array.from(function*() {
      for (const column of columns) {
        for (const row of rows.slice(0, -1)) {
          if (! (column != 0 || row != 3) )
            continue;
          yield triangle_hulls(
            key_place(column, row, local_web_post_bl),
            key_place(column, row, local_web_post_br),
            key_place(column, row + 1, local_web_post_tl),
            key_place(column, row + 1, local_web_post_tr));
        }
      }
    }()));
    const diagonal_connections = tree_union(Array.from(function*() {
      for (const column of columns.slice(0, -1)) {
        for (const row of rows.slice(0, -1)) {
          if (! (column != 0 || row != 3) )
            continue;
          yield triangle_hulls(
            key_place(column, row, local_web_post_br),
            key_place(column, row + 1, local_web_post_tr),
            key_place(column + 1, row, local_web_post_bl),
            key_place(column + 1, row + 1, local_web_post_tl));
        }
      }
    }()));
    const main_keys_bottom = union(
      row_connections, column_connections, diagonal_connections);
    const front_wall = tree_union(Array.from(function*() {
      for (const x of range(2, 5)) {
        yield quickhull3d(
          case_place(x - 1/2, 4, translate([0, 1, 1], wall_sphere_bottom_front())),
          case_place(x + 1/2, 4, translate([0, 1, 1], wall_sphere_bottom_front())),
          key_place(x, 4, half_post_bl),
          key_place(x, 4, half_post_br));
        yield quickhull3d(
          case_place(x - 1/2, 4, translate([0, 1, 1], wall_sphere_bottom_front())),
          key_place(x, 4, half_post_bl),
          key_place(x - 1, 4, half_post_br));
      }
      yield quickhull3d(
        case_place(right_wall_column, 4, translate([0, 1, 1], wall_sphere_bottom_front())),
        case_place(right_wall_column - 1, 4, translate([0, 1, 1], wall_sphere_bottom_front())),
        key_place(5, 4, half_post_bl),
        key_place(5, 4, half_post_br));
      yield quickhull3d(
        case_place(4 + 1/2, 4, translate([0, 1, 1], wall_sphere_bottom_front())),
        case_place(right_wall_column - 1, 4, translate([0, 1, 1], wall_sphere_bottom_front())),
        key_place(4, 4, half_post_br),
        key_place(5, 4, half_post_bl));
    }()));
    const right_wall = tree_union(Array.from(function*() {
      for (x of range(0, 4)) {
        yield quickhull3d(
          case_place(right_wall_column, x, translate([-1, 0, 1], wall_sphere_bottom(1/2))),
          key_place(5, x, local_web_post_br),
          key_place(5, x, local_web_post_tr));
      }
      for (x of range(0, 4)) {
        yield quickhull3d(
          case_place(right_wall_column, x, translate([-1, 0, 1], wall_sphere_bottom(1/2))),
          case_place(right_wall_column, x + 1, translate([-1, 0, 1], wall_sphere_bottom(1/2))),
          key_place(5, x, local_web_post_br),
          key_place(5, x + 1, local_web_post_tr));
      }
      yield quickhull3d(
        case_place(right_wall_column, 0, translate([-1, 0, 1], wall_sphere_bottom(1/2))),
        case_place(right_wall_column, 0.02, translate([-1, -1, 1], wall_sphere_bottom(1))),
        key_place(5, 0, local_web_post_tr));
      yield quickhull3d(
        case_place(right_wall_column, 4, translate([-1, 0, 1], wall_sphere_bottom(1/2))),
        case_place(right_wall_column, 4, translate([0, 1, 1], wall_sphere_bottom(0))),
        key_place(5, 4, half_post_br));
      yield quickhull3d(
        case_place(right_wall_column, 4, translate([-1, 0, 1], wall_sphere_bottom(1/2))),
        key_place(5, 4, half_post_br),
        key_place(5, 4, local_web_post_tr));
    }()));
    const back_wall = tree_union(Array.from(function*() {
      for (x of range(1, 6)) {
        yield quickhull3d(
          case_place(x - 1/2, 0, translate([0, -1, 1], wall_sphere_bottom_back())),
          case_place(x + 1/2, 0, translate([0, -1, 1], wall_sphere_bottom_back())),
          key_place(x, 0, local_web_post_tl),
          key_place(x, 0, local_web_post_tr));
        yield quickhull3d(
          case_place(x - 1/2, 0, translate([0, -1, 1], wall_sphere_bottom_back())),
          key_place(x, 0, local_web_post_tl),
          key_place(x - 1, 0, local_web_post_tr));
      }
      yield quickhull3d(
        case_place(left_wall_column, 0, translate([1, -1, 1], wall_sphere_bottom_back())),
        case_place(left_wall_column + 1, 0, translate([0, -1, 1], wall_sphere_bottom_back())),
        key_place(0, 0, local_web_post_tl),
        key_place(0, 0, local_web_post_tr));
    }()));
    const left_wall = union(Array.from(function*() {
      const place = case_place;
      yield quickhull3d(
        place(left_wall_column, 0, translate([1, -1, 1], wall_sphere_bottom_back())),
        place(left_wall_column, 1, translate([1, 0, 1], wall_sphere_bottom_back())),
        key_place(0, 0, local_web_post_tl),
        key_place(0, 0, local_web_post_bl));
      yield quickhull3d(
        place(left_wall_column, 1, translate([1, 0, 1], wall_sphere_bottom_back())),
        place(left_wall_column, 2, translate([1, 0, 1], wall_sphere_bottom_back())),
        key_place(0, 0, local_web_post_bl),
        key_place(0, 1, local_web_post_bl));
      yield quickhull3d(
        place(left_wall_column, 2, translate([1, 0, 1], wall_sphere_bottom_back())),
        place(left_wall_column, 1.6666,  translate([1, 0, 1], wall_sphere_bottom_front())),
        key_place(0, 1, local_web_post_bl),
        key_place(0, 2, local_web_post_bl));
      yield quickhull3d(
        place(left_wall_column, 1.6666, translate([1, 0, 1], wall_sphere_bottom_front())),
        key_place(0, 2, local_web_post_bl),
        key_place(0, 3, local_web_post_tl));
    }()));
    const thumbs = union(Array.from(function*() {
      yield quickhull3d(
        thumb_place(0, -1/2, local_web_post_bl),
        thumb_place(0, -1/2, local_web_post_tl),
        thumb_place(1, -1/2, local_web_post_tr),
        thumb_place(1, -1/2, local_web_post_br));
      yield quickhull3d(
        thumb_place(1, -1/2, local_web_post_tr),
        thumb_place(1, -1/2, local_web_post_tl),
        thumb_place(1, 1, local_web_post_bl),
        thumb_place(1, 1, local_web_post_br));
      yield quickhull3d(
        thumb_place(2, -1, local_web_post_tr),
        thumb_place(2, -1, local_web_post_tl),
        thumb_place(2, 0, local_web_post_bl),
        thumb_place(2, 0, local_web_post_br));
      yield quickhull3d(
        thumb_place(2, 0, local_web_post_tr),
        thumb_place(2, 0, local_web_post_tl),
        thumb_place(2, 1, local_web_post_bl),
        thumb_place(2, 1, local_web_post_br));
      yield triangle_hulls(
        thumb_place(2, 1, local_web_post_tr),
        thumb_place(1, 1, local_web_post_tl),
        thumb_place(2, 1, local_web_post_br),
        thumb_place(1, 1, local_web_post_bl),
        thumb_place(2, 0, local_web_post_tr),
        thumb_place(1, -1/2, local_web_post_tl),
        thumb_place(2, 0, local_web_post_br),
        thumb_place(1, -1/2, local_web_post_bl),
        thumb_place(2, -1, local_web_post_tr),
        thumb_place(2, -1, local_web_post_br));
      yield quickhull3d(
        thumb_place(2, -1, local_web_post_br),
        thumb_place(1, -1/2, local_web_post_bl),
        thumb_place(1, -1, local_web_post_bl));
      yield quickhull3d(
        thumb_place(1, -1/2, local_web_post_bl),
        thumb_place(1, -1, local_web_post_bl),
        thumb_place(1, -1/2, local_web_post_br),
        thumb_place(1, -1, local_web_post_br));
      yield quickhull3d(
        thumb_place(0, -1/2, local_web_post_bl),
        thumb_place(0, -1, local_web_post_bl),
        thumb_place(0, -1/2, local_web_post_br),
        thumb_place(0, -1, local_web_post_br));
      yield quickhull3d(
        thumb_place(0, -1/2, local_web_post_bl),
        thumb_place(0, -1, local_web_post_bl),
        thumb_place(1, -1/2, local_web_post_br),
        thumb_place(1, -1, local_web_post_br));
    }()));
    const thumb_back_wall = union(Array.from(function*() {
      yield quickhull3d(
        thumb_place(1/2, thumb_back_y, translate([0, -1, 1], wall_sphere_bottom_back())),
        thumb_place(1, 1, local_web_post_tr),
        thumb_place(3/2, thumb_back_y, translate([0, -1, 1], wall_sphere_bottom_back())),
        thumb_place(1, 1, local_web_post_tl));
      yield quickhull3d(
        thumb_place(5/2 + 0.05, thumb_back_y, translate([1, -1, 1], wall_sphere_bottom_back())),
        thumb_place(3/2, thumb_back_y, translate([0, -1, 1], wall_sphere_bottom_back())),
        thumb_place(1, 1, local_web_post_tl),
        thumb_place(2, 1, local_web_post_tl));
      yield quickhull3d(
        thumb_place(1/2, thumb_back_y, translate([0, -1, 1], wall_sphere_bottom_back())),
        case_place(left_wall_column, 1.6666, translate([1, 0, 1], wall_sphere_bottom_front())),
        key_place(0, 3, local_web_post_tl),
        thumb_place(1, 1, local_web_post_tr));
    }()));
    const thumb_left_wall = union(Array.from(function*() {
      yield quickhull3d(
       thumb_place(thumb_left_wall_column, thumb_back_y, translate([1, -1, 1], wall_sphere_bottom_back())),
       thumb_place(thumb_left_wall_column, 0, translate([1, 0, 1], wall_sphere_bottom_back())),
       thumb_place(2, 1, local_web_post_tl),
       thumb_place(2, 1, local_web_post_bl));
      yield quickhull3d(
       thumb_place(thumb_left_wall_column, 0, translate([1, 0, 1], wall_sphere_bottom_back())),
       thumb_place(2, 0, local_web_post_tl),
       thumb_place(2, 1, local_web_post_bl));
      yield quickhull3d(
       thumb_place(thumb_left_wall_column, 0, translate([1, 0, 1], wall_sphere_bottom_back())),
       thumb_place(thumb_left_wall_column, -1, translate([1, 0, 1], wall_sphere_bottom_back())),
       thumb_place(2, 0, local_web_post_tl),
       thumb_place(2, 0, local_web_post_bl));
      yield quickhull3d(
       thumb_place(thumb_left_wall_column, -1, translate([1, 0, 1], wall_sphere_bottom_back())),
       thumb_place(2, -1, local_web_post_tl),
       thumb_place(2, 0, local_web_post_bl));
      yield quickhull3d(
       thumb_place(thumb_left_wall_column, -1, translate([1, 0, 1], wall_sphere_bottom_back())),
       thumb_place(thumb_left_wall_column, -1 + 0.07, translate([1, 1, 1], wall_sphere_bottom_front())),
       thumb_place(2, -1, local_web_post_tl),
       thumb_place(2, -1, local_web_post_bl));
    }()));
    const thumb_front_wall = union(Array.from(function*() {
      yield quickhull3d(
        thumb_place(5/2 + 0.05, thumb_front_row, translate([1, 1, 1], wall_sphere_bottom_front())),
        thumb_place(3/2 + 0.05, thumb_front_row, translate([0, 1, 1], wall_sphere_bottom_front())),
        thumb_place(2, -1, local_web_post_bl),
        thumb_place(2, -1, local_web_post_br));
      yield quickhull3d(
        thumb_place(1/2 + 0.05, thumb_front_row, translate([0, 1, 1], wall_sphere_bottom_front())),
        thumb_place(3/2 + 0.05, thumb_front_row, translate([0, 1, 1], wall_sphere_bottom_front())),
        thumb_place(0, -1, local_web_post_bl),
        thumb_place(1, -1, local_web_post_bl),
        thumb_place(1, -1, local_web_post_br),
        thumb_place(2, -1, local_web_post_br));
      yield quickhull3d(
        thumb_place(thumb_right_wall, thumb_front_row, translate([-1, 1, 1], wall_sphere_bottom_front())),
        thumb_place(1/2 + 0.05, thumb_front_row, translate([0, 1, 1], wall_sphere_bottom_front())),
        thumb_place(0, -1, local_web_post_bl),
        thumb_place(0, -1, local_web_post_br));
    }()));
    const thumb_inside = union(Array.from(function*() {
      yield triangle_hulls(
        thumb_place(1, 1, local_web_post_tr),
        key_place(0, 3, local_web_post_tl),
        thumb_place(1, 1, local_web_post_br),
        key_place(0, 3, local_web_post_bl),
        thumb_place(1, -1/2, local_web_post_tr),
        thumb_place(0, -1/2, local_web_post_tl),
        key_place(0, 3, local_web_post_bl),
        thumb_place(0, -1/2, local_web_post_tr),
        key_place(0, 3, local_web_post_br),
        key_place(1, 3, local_web_post_bl),
        thumb_place(0, -1/2, local_web_post_tr),
        key_place(1, 4, local_web_post_tl),
        key_place(1, 4, half_post_bl));

      yield quickhull3d(
        thumb_place(0, -1/2, local_web_post_tr),
        thumb_place(0, -1/2, local_web_post_br),
        key_place(1, 4, half_post_bl));

      yield quickhull3d(
        key_place(1, 4, half_post_bl),
        key_place(1, 4, half_post_br),
        case_place(2 - 1/2, 4, translate([0, 1, 1], wall_sphere_bottom_front())),
        case_place(0.7, 4, translate([0, 1, 1], wall_sphere_bottom_front())));

      yield quickhull3d(
        thumb_place(0, -1, local_web_post_br),
        thumb_place(0, -1/2, local_web_post_br),
        thumb_place(thumb_right_wall, thumb_front_row, translate([-1, 1, 1], wall_sphere_bottom_front())),
        key_place(1, 4, translate([0, 0, 8.5], local_web_post_bl)),
        key_place(1, 4, half_post_bl));
    }()));
    const stands = union(Array.from(function*() {
      const bumper_diameter = 9.6;
      const bumper_radius = bumper_diameter/2;
      const stand_diameter = bumper_diameter + 2;
      const stand_radius = stand_diameter/2;
      const stand_at = function(place) {
        return difference(
          bottom_hull(
            place(
              translate([0, 0, stand_radius/-2 + -4.5],
                sphere({r: stand_radius, center: true, fn: draft_mode ? 20 : 30})))),
          place(
            translate([0, 0, stand_radius/-2],
              cube({size: [stand_diameter, stand_diameter, stand_radius], center: true}))),
          bottom(1.5, place(
            translate([0, 0, stand_radius/-2 + -4.5],
                sphere({r: bumper_radius, center: true, fn: draft_mode ? 20 : 30})))));
      };
      yield stand_at(function(shape) {return key_place(0, 1, shape)});
      yield stand_at(function(shape) {return thumb_place(1, -1/2, shape)});
      yield stand_at(function(shape) {return key_place(5, 0, shape)});
      yield stand_at(function(shape) {return key_place(5, 3, shape)});
    }()));
    yield main_keys_bottom;
    yield front_wall;
    yield right_wall;
    yield back_wall;
    yield left_wall;
    yield thumbs;
    yield thumb_back_wall;
    yield thumb_left_wall;
    yield thumb_front_wall;
    yield thumb_inside;
    yield stands;
  }()));
}

function shift_hull3d(v, ...shapes) {
  const all_shapes = shapes.slice();
  for (s of shapes) {
    all_shapes.push(translate(v, s));
  }
  return quickhull3d(...all_shapes);
}

function bottom_walls() {
  return tree_union(Array.from(function*() {

    const front_wall = tree_union(Array.from(function*() {
      for (const x of range(2, 5)) {
        yield shift_hull3d([0, 0, -50],
          case_place(x - 1/2, 4, translate([0, 1, 1], wall_sphere_bottom_front())),
          case_place(x + 1/2, 4, translate([0, 1, 1], wall_sphere_bottom_front())));
      }
      yield shift_hull3d([0, 0, -50],
        case_place(right_wall_column, 4, translate([0, 1, 1], wall_sphere_bottom_front())),
        case_place(right_wall_column - 1, 4, translate([0, 1, 1], wall_sphere_bottom_front())));
      yield shift_hull3d([0, 0, -50],
        case_place(4 + 1/2, 4, translate([0, 1, 1], wall_sphere_bottom_front())),
        case_place(right_wall_column - 1, 4, translate([0, 1, 1], wall_sphere_bottom_front())));
    }()));
    const right_wall = tree_union(Array.from(function*() {
      for (x of range(0, 4)) {
        yield shift_hull3d([0, 0, -50],
          case_place(right_wall_column, x, translate([-1, 0, 1], wall_sphere_bottom(1/2))),
          case_place(right_wall_column, x + 1, translate([-1, 0, 1], wall_sphere_bottom(1/2))));
      }
      yield shift_hull3d([0, 0, -50],
        case_place(right_wall_column, 0, translate([-1, 0, 1], wall_sphere_bottom(1/2))),
        case_place(right_wall_column, 0.02, translate([-1, -1, 1], wall_sphere_bottom(1))));
      yield shift_hull3d([0, 0, -50],
        case_place(right_wall_column, 4, translate([-1, 0, 1], wall_sphere_bottom(1/2))),
        case_place(right_wall_column, 4, translate([0, 1, 1], wall_sphere_bottom(0))));
    }()));
    const back_wall = tree_union(Array.from(function*() {
      for (x of range(1, 6)) {
        yield shift_hull3d([0, 0, -50],
          case_place(x - 1/2, 0, translate([0, -1, 1], wall_sphere_bottom_back())),
          case_place(x + 1/2, 0, translate([0, -1, 1], wall_sphere_bottom_back())));
      }
      yield shift_hull3d([0, 0, -50],
        case_place(left_wall_column, 0, translate([1, -1, 1], wall_sphere_bottom_back())),
        case_place(left_wall_column + 1, 0, translate([0, -1, 1], wall_sphere_bottom_back())));
    }()));
    const left_wall = union(Array.from(function*() {
      const place = case_place;
      yield shift_hull3d([0, 0, -50],
        place(left_wall_column, 0, translate([1, -1, 1], wall_sphere_bottom_back())),
        place(left_wall_column, 1, translate([1, 0, 1], wall_sphere_bottom_back())));
      yield shift_hull3d([0, 0, -50],
        place(left_wall_column, 1, translate([1, 0, 1], wall_sphere_bottom_back())),
        place(left_wall_column, 2, translate([1, 0, 1], wall_sphere_bottom_back())));
      yield shift_hull3d([0, 0, -50],
        place(left_wall_column, 2, translate([1, 0, 1], wall_sphere_bottom_back())),
        place(left_wall_column, 1.6666,  translate([1, 0, 1], wall_sphere_bottom_front())));
    }()));
    const thumb_back_wall = union(Array.from(function*() {
      yield shift_hull3d([0, 0, -50],
        thumb_place(1/2, thumb_back_y, translate([0, -1, 1], wall_sphere_bottom_back())),
        thumb_place(3/2, thumb_back_y, translate([0, -1, 1], wall_sphere_bottom_back())));
      yield shift_hull3d([0, 0, -50],
        thumb_place(5/2 + 0.05, thumb_back_y, translate([1, -1, 1], wall_sphere_bottom_back())),
        thumb_place(3/2, thumb_back_y, translate([0, -1, 1], wall_sphere_bottom_back())));
      yield shift_hull3d([0, 0, -50],
        thumb_place(1/2, thumb_back_y, translate([0, -1, 1], wall_sphere_bottom_back())),
        case_place(left_wall_column, 1.6666, translate([1, 0, 1], wall_sphere_bottom_front())));
    }()));
    const thumb_left_wall = union(Array.from(function*() {
      yield shift_hull3d([0, 0, -50],
       thumb_place(thumb_left_wall_column, thumb_back_y, translate([1, -1, 1], wall_sphere_bottom_back())),
       thumb_place(thumb_left_wall_column, 0, translate([1, 0, 1], wall_sphere_bottom_back())));
      yield shift_hull3d([0, 0, -50],
       thumb_place(thumb_left_wall_column, 0, translate([1, 0, 1], wall_sphere_bottom_back())));
      yield shift_hull3d([0, 0, -50],
       thumb_place(thumb_left_wall_column, 0, translate([1, 0, 1], wall_sphere_bottom_back())),
       thumb_place(thumb_left_wall_column, -1, translate([1, 0, 1], wall_sphere_bottom_back())));
      yield shift_hull3d([0, 0, -50],
       thumb_place(thumb_left_wall_column, -1, translate([1, 0, 1], wall_sphere_bottom_back())));
      yield shift_hull3d([0, 0, -50],
       thumb_place(thumb_left_wall_column, -1, translate([1, 0, 1], wall_sphere_bottom_back())),
       thumb_place(thumb_left_wall_column, -1 + 0.07, translate([1, 1, 1], wall_sphere_bottom_front())));
    }()));
    const thumb_front_wall = union(Array.from(function*() {
      yield shift_hull3d([0, 0, -50],
        thumb_place(5/2 + 0.05, thumb_front_row, translate([1, 1, 1], wall_sphere_bottom_front())),
        thumb_place(3/2 + 0.05, thumb_front_row, translate([0, 1, 1], wall_sphere_bottom_front())));
      yield shift_hull3d([0, 0, -50],
        thumb_place(1/2 + 0.05, thumb_front_row, translate([0, 1, 1], wall_sphere_bottom_front())),
        thumb_place(3/2 + 0.05, thumb_front_row, translate([0, 1, 1], wall_sphere_bottom_front())));
      yield shift_hull3d([0, 0, -50],
        thumb_place(thumb_right_wall, thumb_front_row, translate([-1, 1, 1], wall_sphere_bottom_front())),
        thumb_place(1/2 + 0.05, thumb_front_row, translate([0, 1, 1], wall_sphere_bottom_front())));
    }()));
    const thumb_inside = union(Array.from(function*() {
      yield shift_hull3d([0, 0, -50],
        case_place(2 - 1/2, 4, translate([0, 1, 1], wall_sphere_bottom_front())),
        case_place(0.7, 4, translate([0, 1, 1], wall_sphere_bottom_front())));

      yield shift_hull3d([0, 0, -50],
        thumb_place(thumb_right_wall, thumb_front_row, translate([-1, 1, 1], wall_sphere_bottom_front())),
        case_place(0.7, 4, translate([0, 1, 1], wall_sphere_bottom_front())));
    }()));
    yield front_wall;
    yield right_wall;
    yield back_wall;
    yield left_wall;
    yield thumb_back_wall;
    yield thumb_left_wall;
    yield thumb_front_wall;
    yield thumb_inside;
  }()));
}

// Given a 2d polygon, remove all clockwise polygons (the holes) from it.
function remove_holes_2d(shape) {
  let path_ends = {};
  let i = 0;
  for (side of shape.sides) {
    if (side.vertex0 in path_ends) {
      const path = path_ends[side.vertex0];
      path.push(side);
      delete path_ends[side.vertex0];
      path_ends[side.vertex1] = path;
    } else {
      const path = [side];
      path_ends[side.vertex1] = path;
    }
  }
  let path_starts = {};
  for (path_end in path_ends) {
    let path = path_ends[path_end];
    while (true) {
      const path_start = path[0].vertex0;
      if (path_start != path_end && path_start in path_ends) {
        path = path_ends[path_start].concat(path);
        delete path_ends[path_start];
        path_ends[path_end] = path;
      } else {
        break;
      }
    }
  }
  const keep = [];
  for (path_end in path_ends) {
    let sides = path_ends[path_end];
    let path = sides.map(side => [side.vertex0.pos.x, side.vertex0.pos.y]);
    if (Is2DPathCounterClockwise(path)) {
      console.log(path);
      keep.push(polygon(path));
    }
  }
  return tree_union(keep);
}

function extended_bottom_plate() {
  // cut off the parts of the walls that extend past 0 z.
  const walls = difference(bottom_walls(), translate([0, 0, -100], cube({size: [200, 200, 200], center:true})));
  // Just in case the walls aren't completely vertical, get the bottom 1mm of the walls.
  const bottom_parameter = intersection(walls, translate([0, 0, 0.5], cube({size: [200, 200, 1], center:true})));
  const bottom_parameter2d = projection(bottom_parameter);
  // Fill in the parameter.
  const base2d = remove_holes_2d(bottom_parameter2d);
  const base = linear_extrude({ height: 1.5 }, base2d);
  const cropped_sheaths = intersection(nut_sheaths(), linear_extrude({ height: 60 }, base2d));
  return difference(union(walls, base, cropped_sheaths), nut_holes());
}

function regular_polygon(radius, sides) {
  points = [];
  for (let i = 0; i < sides; i++) {
    points.push([radius * cos(360 * i / sides), radius * sin(360 * i / sides)]);
  }
  console.log(points);
  return polygon(points);
}

function screw_hole() {
  return translate([0, 0, 3/2],
    cylinder({r: 1.5, h: 60, center: true, fn: wall_sphere_n}));
}

function nut_hole() {
  return translate([0, 0, -60 -10], linear_extrude({ height: 60 }, regular_polygon(3.1, 6)));
}

function nut_sheath() {
  return translate([0, 0, -60 -10 + 1.5], linear_extrude({ height: 60 }, regular_polygon(3.1 + 1.5, 6)));
}

function screw_position_place(shape) {
  return union(Array.from(function*() {
    yield key_place(4 + 1/2, 1/2, shape);
    yield key_place(4 + 1/2, 3 + 1/2, shape);
    yield thumb_place(2, -1/2, shape);

    if (params.extra_screw) {
      yield key_place(0 + 1/2, 1 + 1/2, shape);
    }
  }()));
}

function screw_holes() {
  return screw_position_place(screw_hole());
}

function nut_holes() {
  return screw_position_place(nut_hole());
}

function nut_sheaths() {
  return screw_position_place(nut_sheath());
}

function led_hole() {
  return color([0, 0, 1], translate([0, 0, 7/4],
    cylinder({r1: 1.6, r2: 1.5, h: 4, center: true, fn: wall_sphere_n})));
}

function led_holes() {
  console.log("led_holes");
  return union(Array.from(function*() {
    for (const column of columns) {
      yield key_place(column, 1/2,
        led_hole());
    }
  }()));
}

function circuit_cover(width, length, height) {
  const cover_sphere_radius = 1;
  const cover_sphere =
    sphere({r: cover_sphere_radius, center: true, fn: 20});
  const cover_sphere_z = -height + -cover_sphere_radius;
  const cover_sphere_x = width/2 + cover_sphere_radius;
  const cover_sphere_y = length/2 + cover_sphere_radius;
  const cover_sphere_tl = key_place(1/2, 3/2,
    translate([-cover_sphere_x, -cover_sphere_y, cover_sphere_z], cover_sphere));
  const cover_sphere_tr = key_place(1/2, 3/2,
    translate([cover_sphere_x, -cover_sphere_y, cover_sphere_z], cover_sphere));
  const cover_sphere_br = key_place(1/2, 3/2,
    translate([cover_sphere_x, cover_sphere_y, cover_sphere_z], cover_sphere));
  const cover_sphere_bl = key_place(1/2, 3/2,
    translate([-cover_sphere_x, cover_sphere_y, cover_sphere_z], cover_sphere));
  const lower_to_bottom = function (shape) {
    return translate([0, 0, -cover_sphere_radius + -5.5], shape);
  };
  const bl = key_place(0, 1/2, lower_to_bottom(cover_sphere));
  const br = key_place(1, 1/2, lower_to_bottom(cover_sphere));
  const tl = key_place(0, 5/2, lower_to_bottom(cover_sphere));
  const tr = key_place(1, 5/2, lower_to_bottom(cover_sphere));
  const mlb = key_place(1/2, 3/2,
    translate([-cover_sphere_x, 0, -height + -1], cover_sphere));
  const mrb = key_place(1/2, 3/2,
    translate([cover_sphere_x, 0, -height + -1], cover_sphere));
  const mlt = key_place(1/2, 3/2,
    translate([-cover_sphere_x + -4, 0, -6], cover_sphere));
  const mrt = key_place(1/2, 3/2,
    translate([cover_sphere_x + 4, 0, -6], cover_sphere));
  return union(
     quickhull3d(cover_sphere_bl, cover_sphere_br, cover_sphere_tl, cover_sphere_tr),
     quickhull3d(cover_sphere_br, cover_sphere_bl, bl, br),
     quickhull3d(cover_sphere_tr, cover_sphere_tl, tl, tr),
     quickhull3d(cover_sphere_tl, tl, mlb, mlt),
     quickhull3d(cover_sphere_bl, bl, mlb, mlt),
     quickhull3d(cover_sphere_tr, tr, mrb, mrt),
     quickhull3d(cover_sphere_br, br, mrb, mrt));
}

const io_exp_width = 10;
const io_exp_height = 8;
const io_exp_length = 36;

const teensy_width = 20;
const teensy_height = 12;
const teensy_length = 33;

function io_exp_cover() {
  return circuit_cover(io_exp_width, io_exp_length, io_exp_height);
}
function teensy_cover() {
  return circuit_cover(teensy_width, teensy_length, teensy_height);
}

const trrs_diameter = 6.6;
const trrs_radius = trrs_diameter/2;
const trrs_hole_depth = 10;

function trrs_hole() {
  const shape = union(
    cylinder({r: trrs_radius, h: trrs_hole_depth, center: true, fn: 50}),
    translate([0, (trrs_radius + 5)/2, 0],
      cube({size: [trrs_diameter, trrs_radius + 5, trrs_hole_depth], center: true})));

  return translate([0, mount_height/2 + 4, -trrs_radius],
    rotate(Math.PI / 2 * 180 / Math.PI, [1, 0, 0], shape));
}

function trrs_hole_just_circle() {
  console.log("trrs_hole_just_circle");
  return key_place(1/2, 0,
    translate([0, mount_height/2 + 4, -trrs_radius],
      rotate(Math.PI/2*180/Math.PI, [1, 0, 0],
        cylinder({r: trrs_radius, h: trrs_hole_depth, center: true, fn: 50}))));
}

function trrs_box_hole() {
  return translate([0, 1, -3.5],
    cube({size: [14, 14, 7], center: true}));
}

function extended_trrs_cutout() {
  return translate([-30, 50, 7], rotate(90, [1, 0, 0],
    cylinder({r: 4, h: 20, center:true, fn: 20})));
}

function trrs_cutout() {
  return key_place(1/2, 0, trrs_hole(), trrs_box_hole());
}

const teensy_pcb_thickness = 1.6;
const teensy_offset_height = 5;

function teensy_pcb() {
  return color([1, 0, 0],
    key_place(1/2, 3/2,
      translate([0, 0, teensy_pcb_thickness/-2 + -teensy_offset_height],
        cube({size: [18, 30.5, teensy_pcb_thickness], center: true}))));
}

function teensy_support() {
  return difference(
    union(
      color([0, 1, 0],
        key_place(1/2, 3/2,
          translate([0, 0, -2],
            cube({size: [3, 3, 9], center: true})))),
      quickhull3d(
        color([0, 0, 1],
          key_place(1/2, 2,
            translate([0, 0, -2],
              cube({size: [3, 6, 9], center: true})))),
        color([0, 0, 1],
          key_place(1/2, 3/2,
            translate([0, 30.5/-2,
                -teensy_offset_height /* + (teensy_pcb_thickness + 3)/-2 */],
              cube({size: [3, 3, teensy_pcb_thickness + 3], center: true})))))),
    teensy_pcb(),
    color([1, 0, 0],
      key_place(1/2, 3/2,
        translate([0, 1.5, teensy_pcb_thickness/-2 + -teensy_offset_height + -1],
          cube({size: [18, 30.5, teensy_pcb_thickness], center: true})))));
}

function extended_usb_cutout(params) {
  /*
     Designed for the Adafruit Micro USB panel mount:
     https://cdn-shop.adafruit.com/product-files/3258/Micro+USB.pdf
  */
  const screw_hole = cylinder({r: 1.75, h: 20, center:true, fn: 20});
  const connector_face = cube({size: [9.5, 5, 20], center: true});
  return translate([-10, 50, 7], rotate(90, [1, 0, 0],
    translate([-8.65, 0, 0], screw_hole),
    translate([8.65, 0, 0], screw_hole),
    connector_face));
}

function usb_cutout() {
  const hole_height = 6.2;
  const side_radius = hole_height/2;
  const hole_width = 10.75;
  const side_cylinder = translate([(hole_width - hole_height)/2, 0, 0],
    cylinder({r: side_radius, h: teensy_length, center: true, fn: 20}));

  return key_place(1/2, 3/2,
    translate([0, 0, -teensy_offset_height],
      translate([0, 0, -1],
        translate([0, teensy_length/2, -side_radius],
          rotate(Math.PI/2*180/Math.PI, [1, 0, 0],
            quickhull3d(side_cylinder,
              mirror([-1, 0, 0], side_cylinder)))))));
}

/*****************
** Final Export **
*****************/

function dactyl_bottom_right(params) {
  return difference(
    union(
      teensy_cover(),
      difference(
        bottom_plate(),
        quickhull3d(teensy_cover()),
        new_case(),
        teensy_cover(),
        trrs_cutout(),
        translate([0, 0, -5], cube({size: [1000, 1000, 10], center: true})),
        screw_holes(params))),
    usb_cutout());

}
function dactyl_extended_bottom_right(params) {
  return difference(
    dactyl_extended_bottom_left(),
    extended_usb_cutout(params)
  );
}

function dactyl_extended_bottom_left(params) {
  return difference(
    extended_bottom_plate(),
    new_case(),
    extended_trrs_cutout(),
    screw_holes()
  );
}

function dactyl_bottom_left(params) {
  return mirror([-1, 0, 0],
    union(
      io_exp_cover(),
      difference(
        bottom_plate(),
        quickhull3d(io_exp_cover()),
        new_case(),
        io_exp_cover(),
        trrs_cutout(),
        translate([0, 0, -5], cube({size: [1000, 1000, 10], center: true})),
        screw_holes(params))));
}

function dactyl_top_right(params) {
  let add = [
    key_holes(params),
    connectors(),
    thumb(),
    new_case(),
  ];
  if (params.teensy_support) {
    add.push(teensy_support());
  }
  let remove = [
    trrs_hole_just_circle(),
    screw_holes(params)];
  if (params.led_holes) {
    remove.push(led_holes());
  }
  return difference(
    union(add),
    ...remove);
}

function dactyl_top_left(params) {
  let add = [
    key_holes(params),
    connectors(),
    thumb(),
    new_case()
  ];
  let remove = [
    trrs_hole_just_circle(),
    screw_holes(params)];
  if (params.led_holes) {
    remove.push(led_holes());
  }
  return mirror([-1, 0, 0],
    difference(
      union(add),
      ...remove
    ));
}

function getParameterDefinitions() {
  return [
    { name: 'draft', type: 'checkbox', checked: true, caption: 'Draft (non-draft takes 10 minutes)' }, 
    { name: 'extra_screw', type: 'checkbox', checked: true, caption: 'Extended bottom screw hole' },
    { name: 'led_holes', type: 'checkbox', checked: true, caption: 'Push holes for leds' },
    { name: 'teensy_support', type: 'checkbox', checked: false, caption: 'Add support for teensy board' },
    { name: 'key_switch', type: 'choice', caption: 'key switch',
      values: [
        "cherry",
        "alps",
        ],
      captions: [
        "cherry",
        "alps",
      ],
      initial: dactyl_bottom_right },
    { name: 'part', type: 'choice', caption: 'Part',
      values: [
        "dactyl_bottom_right",
        "dactyl_bottom_left",
        "dactyl_extended_bottom_right",
        "dactyl_extended_bottom_left",
        "dactyl_top_right",
        "dactyl_top_left",
        ],
      captions: [
        "bottom right",
        "bottom left",
        "extended bottom right",
        "extended bottom left",
        "top right",
        "top left",
      ],
      initial: dactyl_bottom_right },
  ];
}

function main(params) {
  draft_mode = params.draft;
  gl_vec3();
  switch (params.part) {
    case "dactyl_bottom_right":
      return dactyl_bottom_right(params);
    case "dactyl_bottom_left":
      return dactyl_bottom_left(params);
    case "dactyl_extended_bottom_right":
      return dactyl_extended_bottom_right(params);
    case "dactyl_extended_bottom_left":
      return dactyl_extended_bottom_left(params);
    case "dactyl_top_right":
      return dactyl_top_right(params);
    case "dactyl_top_left":
      return dactyl_top_left(params);
  }
}
